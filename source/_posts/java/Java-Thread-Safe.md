---
title: Java 线程安全
description: 如何在多线程下安全优雅的处理共享变量，是Java并发处理的难点。本文通过Java内存模型为切入点，庖丁解牛一步步带你揭开线程安全的面纱。
categories: 
- Java
---

如何在多线程下安全优雅的处理共享变量，是Java并发处理的难点。本文通过Java内存模型为切入点，庖丁解牛一步步带你揭开线程安全的面纱。

## 为什么要有内存模型

在讲解Java内存模型前，我们先探讨一下为什么需要实现内存模型？这牵扯到两个知识点：CPU缓存一致性和指令重排。

### CPU缓存一致性

我们知道CPU是计算机的心脏，程序的每一条指令都要通过CPU来执行，而执行的时候，或多或少的需要和内存打交道，一开始的时候，CPU是直接和内存交互的。

![java-thread-safe-1](/images/java/java-thread-safe-1.jpg)

但是随着技术的迭代，CPU的运算速度成指数级上升，而内存技术有所滞后，导致每次CPU读写内存时都要耗费大量的等待时间。不得已之下，人们想到在CPU和内存之间增加高速缓存，将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。

![java-thread-safe-2](/images/java/java-thread-safe-2.jpg)

高速缓存虽然解决来CPU与内存之间速度不一致的矛盾，但也带来了在多核CPU下，缓存不一致的问题

![java-thread-safe-3](/images/java/java-thread-safe-3.jpg)

在多核系统中，每一个CPU都拥有自己的高速缓存，同时又共享同一主内存。假设多个CPU的运算任务都涉及到同一块内存，将可能导致各自的缓存数据不一致，如果真的这样，那同步回到主内存时以谁的缓存数据为准呢？这就需要内存模型实现一套缓存一致协议，来避免数据错乱导致的问题。

### 重排

指令重排指的是处理器出于优化的目的，对代码执行顺序进行的重新排列。比如我们的代码顺序是`A->B->C`，但CPU在处理这段代码的时候觉得B先处理效率更高，那么可能的顺序就变成`B->A->C`，但这里需要指出的是顺序的颠倒不能改变输出结果，也就是说`A->B->C`和`B->A->C`的执行结果应该是一致的。这个过程是比较复杂的，什么样的代码可以重排什么样的不可以，需要一套严谨的规则。

### 小结

内存模型的作用有两个：

1. 在多核系统下实现CPU缓存一致性
2. 实现指令重排的规则

## Java内存模型

为了避免不同硬件和系统对内存访问的差异（缓存一致性和指令重排等），Java定义了内存模型规范（JMM），以实现不同平台下对内存访问的一致性。话不多说，先上图：

![java-thread-safe-4](/images/java/java-thread-safe-4.jpg)

Java内存模型中有几个关键点：

1. Java内存模型把内存划分为主内存和工作内存。
2. 每个线程都有自己的独立工作内存，工作内存中存储着该线程所需的共享变量的拷贝（主内存的副本），线程对变量的所有操作（读取、写入等）都必须工作内存中进行。为了便于理解，用图来描述一下线程对变量赋值的流程。

![java-thread-safe-5](/images/java/java-thread-safe-5.jpg)

3. 线程之间变量的共享只能通过主内存进行，线程不能直接操作对方工作内存中的变量。

## 线程安全

对于“线程安全”，相信大部分同学在多线程开发场景中都或多或少提及，但如何给出一个准确的定义却不太容易，下面的定义摘录自《深入理解Java虚拟机》：

> ”当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的“

这段定义比较拗口，我们需要从中抽取几个关键字：“多个线程”、“同一个对象”、“正确的结果”，这样我们可以给出简单但不严谨的定义：

> 多个线程访问同一个对象，并产生正确的结果，那么这个对象可以称之为线程安全的

线程安全一般需要满足几个条件：

> 需要说明的是三个条件的同时满足对于线程安全是必要不充分条件，也就是说如果三个条件同时满足那么我们可以认为这是线程安全的，但是线程安全在某些情况下却不一定都要满足这三个条件。

1. 原子性

原子在化学反应中是不可分隔的。对应在代码层面是指对于共享变量的操作是连续的不可分隔的整体。

2. 可见性

可见性是指一个线程对共享变量操作的结果是可以立刻被其他线程所知晓的。

如下图，存在两个线程A和B，线程A对共享变量`x`进行了赋值操作，使得`x`的值为`1`，为了保证可见性，线程A对`x`应立即刷新到主内存，确保线程B可以读到正确值。

![java-thread-safe-6](/images/java/java-thread-safe-6.jpg)

3. 有序性

前面有提到处理器出于某些原因会对代码的执行顺序进行调整，而有序性就是要避免进行指令重排。

## 线程安全的解决

### `synchronized` 关键字

`synchronized`是Java中解决并发问题的一种最常用的方法，从语法上讲，Synchronized总共有三种用法：

1. 修饰普通方法

```java
public synchronized void normalMethod(){}
```

2. 修饰静态方法

```java
public static synchronized void staticMethod(){}
```

3. 修饰代码块

```java
//....
synchronized (this){
    //....
}
```

#### `synchronized`的作用

- 确保原子性

被`synchronized`修饰的对象是互斥的，即同一时间只能被一个线程使用。

这里需要注意的是：<b>`synchronized`锁住的是对象而不是某段代码</b>，比如下面这段代码，当线程1调用方法`f1`时，线程2是如果想`A`中的任何方法都会被阻塞，只有等线程1完成对`f1`的调用后线程2能调用方法。

```java
public class A{
     synchronized f1(){}
     synchronized f2(){}
}
A a = new A();
```

那么`synchronized`是如何实现互斥的呢？

每个对象都有一个监视器锁（monitor），synchronized关键字经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令。

当线程1要调用这个代码时，就会执行monitorenter指令，该指令回去尝试获取对象锁，如果这个对象的锁没有被其他线程占用，那么该线程就会获得对象锁的使用权，否则当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。

当线程1执行完所调用的代码后就会执行monitorexit指令，释放锁资源。

![java-thread-safe-7](/images/java/java-thread-safe-7.gif)

> 动图来自[图解 Java 线程安全](https://juejin.im/post/5d2c97bff265da1bc552954b)，侵删

- 确保可见性

可见性的关键点在于可以及时刷新和读取主内存中的变量值，对此JMM对`synchronized`有两天约定：

1. 线程在解锁前，必须包共享变量的最新值刷新到主内存中
2. 线程在加锁前，将清空工作内存中的共享变量值，并从主内存中读取最新值

- 确保有序性

### `volatile` 关键字

## 参考

- 深入理解Java虚拟机
- [细说Java多线程之内存可见性](https://www.imooc.com/learn/352)
- [全面理解Java内存模型(JMM)及volatile关键字](https://blog.csdn.net/javazejian/article/details/72772461)
- [Java同步锁解析](http://bigdatadecode.club/Java%E5%90%8C%E6%AD%A5%E9%94%81%E8%A7%A3%E6%9E%90.html)